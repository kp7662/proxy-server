package main

import (
	"bytes"
	"container/list"
	"crypto/sha1"
	"encoding/gob"
	"encoding/hex"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"time"
)

// CacheEntry represents a HTTP cache entry
type CacheEntry struct {
	Body         []byte      // The http response body
	Header       http.Header // The http response headers
	StatusCode   int         // The http response status code
	MaxAge       int64       // Max age of the cache file
	LastModified string      // Last modified date of the cache file
	CreationTime time.Time   // Time when the cache file is created

}

// HTTPCache defines the structure for an HTTP cache
// cacheDir holds the directory path where the cache is stored
// The key is the hash value of the URL string,
// and the value is a slice of bytes representing the cached response body
type HTTPCache struct {
	cacheDir    string
	lruQueue    *list.List
	currentSize int
	maxCap      int
	cacheData   map[string]*list.Element
}

// Creates a HTTPCache object
func NewHTTPCache() *HTTPCache {
	cacheDir := "./http_cache" // Set the cache directory name
	// Create the cache directroy with permission to be fully accessible by user
	os.MkdirAll(cacheDir, os.ModePerm)
	// Return a pointer to the new HTTPCache
	return &HTTPCache{
		cacheDir:    cacheDir,
		lruQueue:    list.New(),
		currentSize: 0,
		maxCap:      200,
		cacheData:   make(map[string](*list.Element)),
	}
}

// MaxStorage returns the maximum number of bytes this LRU can store
func (c *HTTPCache) MaxStorage() int {
	return c.maxCap

}

// RemainingStorage returns the number of unused bytes available in this LRU
func (c *HTTPCache) RemainingStorage() int {
	return (c.maxCap - c.currentSize)
}

// CacheKey generates a unique hashed key for caching an HTTP request
// It takes an http.Request pointer as input and returns a string
// The key is generated by hashing the request URL using SHA-1,
// and then encoding the hash as a hexadecimal string. This ensures
// that each URL gets a unique, consistent, and filesystem-safe key
func (c *HTTPCache) CacheKey(req *http.Request) string {
	key := req.URL.String() // Convert the request URL to a string
	h := sha1.New()
	h.Write([]byte(key))
	return hex.EncodeToString(h.Sum(nil))
}

// Bytes converts CacheEntry data into a sequence of bytes that can be
// stored more efficiently
func (e CacheEntry) Bytes() []byte {
	var buffer bytes.Buffer
	encoder := gob.NewEncoder(&buffer)
	// Encode the CacheEntry object into a binary format
	// Purpose: faster, no additional parsing required, more compact
	// data representation
	err := encoder.Encode(e)
	if err != nil {
		panic(err)
	}
	return buffer.Bytes()
}

// CacheEntryFromBytes decodes CacheEntry object from its binary representation
// stored a cache
func CacheEntryFromBytes(data []byte) *CacheEntry {
	var entry CacheEntry
	buffer := bytes.NewBuffer(data)
	decoder := gob.NewDecoder(buffer)
	// Decodes the CacheEntry back from the cached file to be sent to client
	err := decoder.Decode(&entry)
	if err != nil {
		panic(err)
	}
	return &entry
}

// Put stores a http response in the HTTP cache. It takes an http.Request and http.Response,
// along with maxAge and lastModified values, and saves the response data to a cache file
// The response body is also returned as a bytes.Buffer so it can be sent to the client
func (c *HTTPCache) Put(req *http.Request, resp *http.Response, maxAge int64, lastModified string) (bod bytes.Buffer) {
	c.currentSize = c.currentSize + 1
	log.Println("Current size after putting one", c.currentSize)
	change := 0
	// Evict items if adding the new pair would exceed the limit
	for (c.currentSize - change) > c.maxCap {
		oldestElement := c.lruQueue.Back() // Get the least recently used key
		stringkey := oldestElement.Value.(string)
		change = change + 1
		log.Println("MaxCap Reached...removing")
		c.RemoveCache(stringkey)

	}
	key := c.CacheKey(req)
	filePath := filepath.Join(c.cacheDir, key)
	var bodyBuffer bytes.Buffer

	// Copy the response body into the buffer to prevent reading
	// the response body directly before it's sent to the client
	_, err := io.Copy(&bodyBuffer, resp.Body)
	if err != nil {
		log.Printf("Error copying response body: %v", err)
		return
	}

	// Store the copied response body to be returned
	returnedbody := bodyBuffer
	entry := CacheEntry{
		Body:         returnedbody.Bytes(),
		Header:       resp.Header,
		MaxAge:       maxAge,
		LastModified: lastModified,
		CreationTime: time.Now(),
		StatusCode:   resp.StatusCode,
	}

	// Convert the cache entry into binary format
	serializedData := entry.Bytes()
	err = os.WriteFile(filePath, serializedData, 0666)
	if err != nil {
		log.Printf("Error writing cache file: %v", err)
	}
	//c.currentSize = m - change
	// Update the order of elements in lruQueue by adding the key to the back
	c.cacheData[key] = c.lruQueue.PushFront(key)
	log.Println("Current size after removing if needed", c.currentSize)
	return returnedbody
}

// Get retrieves a cached HTTP response for a given request
// It returns the cached http.Response if available and a boolean indicating
// whether the cache hit was successful
func (c *HTTPCache) Get(req *http.Request) (*http.Response, bool) {
	key := c.CacheKey(req)

	filePath := filepath.Join(c.cacheDir, key)

	// Attempt to read the cached data from the file system
	data, err := os.ReadFile(filePath)
	if err != nil {
		// If the file doesn't exist, it means the response is not cached,
		// return nil and false
		if os.IsNotExist(err) {
			return nil, false
		}
		log.Printf("Error reading cache file: %v", err)
		return nil, false
	}

	// Converts the byte data back into a CacheEntry object
	entry := CacheEntryFromBytes(data)

	// Check if the cache entry is stale. If it is, remove it and return no response
	if (entry).isStale() {
		log.Printf("Cache entry for key: %s is stale.", key)
		c.RemoveCache(key)
		return nil, false
	}

	response := &http.Response{
		StatusCode: entry.StatusCode,
		Body:       io.NopCloser(bytes.NewBuffer(entry.Body)),
		Header:     entry.Header,
	}
	c.lruQueue.MoveToFront(c.cacheData[key])

	return response, true
}

// init is a special Go function that gets called automatically when its package is initialized
func init() {
	// Register the http.Header type with the encoding/gob package
	// This is necessary because http.Header is a map type (map[string][]string),
	// and maps with non-standard key types (like string in this case)
	// need to be registered with gob to be correctly encoded/decoded
	gob.Register(http.Header{})
}

// RemoveCache deletes a stale cached file associated with a given key
func (c *HTTPCache) RemoveCache(key string) {
	filePath := filepath.Join(c.cacheDir, key)
	// log.Printf("Removing filePath (%s) from Cache...\n", filePath)
	c.lruQueue.Remove(c.cacheData[key])
	delete(c.cacheData, key)
	c.currentSize = c.currentSize - 1
	// Attempt to remove the cache file from the file system
	err := os.Remove(filePath)
	if err != nil {
		log.Printf("Error removing filePath (%s) from Cache: %v\n", filePath, err)
		return
	}

	log.Printf("FilePath (%s) removed from Cache successfully!\n", filePath)
}

// isStale checks if the cache entry is stale based on its MaxAge value
// It returns true if the cache entry is considered stale, and false otherwise
func (e CacheEntry) isStale() bool {
	// If MaxAge is set to 0, the cache entry is always considered stale
	if e.MaxAge == 0 {
		log.Println("Cache is stale: maxAge is 0")
		return true

	} else if e.MaxAge > 0 {
		// Calculate the current age of the cache entry by subtracting its creation time from the current time
		age := time.Since(e.CreationTime) // in nanoseconds

		// Convert maxAge to its time.Duration equivalence
		maxAgeDuration := time.Duration(e.MaxAge) * time.Second // in nanoseconds

		// Check if the age of the cache entry exceeds its MaxAge
		// If the cache entry is older than the MaxAge, it is considered stale
		// If the cache entry is younger than or equal to the MaxAge, it is not stale
		if age > maxAgeDuration {
			log.Printf("Cache is stale: age (%v) > maxAge (%v)\n", age, maxAgeDuration)
			return true
		} else {
			log.Printf("Cache is not stale: age (%v) <= maxAge (%v)\n", age, maxAgeDuration)
			return false
		}
	}

	// If MaxAge is negative, the cache entry is considered stale by default
	log.Println("Cache is stale: maxAge is negative")
	return true
}
